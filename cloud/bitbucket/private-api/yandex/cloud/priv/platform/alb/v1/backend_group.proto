syntax = "proto3";

package yandex.cloud.priv.platform.alb.v1;

import "google/protobuf/duration.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/wrappers.proto";
import "yandex/cloud/api/tools/options.proto";
import "yandex/cloud/priv/platform/alb/v1/payload.proto";
import "yandex/cloud/priv/platform/alb/v1/protocol_options.proto";
import "yandex/cloud/priv/platform/alb/v1/target_group.proto";
import "yandex/cloud/priv/platform/alb/v1/tls.proto";
import "yandex/cloud/priv/validation.proto";

option go_package = "a.yandex-team.ru/cloud/bitbucket/private-api/yandex/cloud/priv/platform/alb/v1;alb";
option java_outer_classname = "PALBG";

message BackendGroup {
  // UID generated by ALB.
  string id = 1;

  // Name. TODO: requirements.
  string name = 2;

  // Comment.
  string description = 3;

  // For auth checks.
  string folder_id = 4;

  // More comments.
  map<string, string> labels = 5;

  oneof backend {
    StreamBackendGroup stream = 6;
    HttpBackendGroup http = 7;
    GrpcBackendGroup grpc = 8;
  }

  google.protobuf.Timestamp created_at = 9;

  // Contains list of HTTP router IDs that refer to this backend group.
  repeated string http_router_ids = 10;

  // Contains list of Application Load Balancer IDs that refer to this backend group.
  repeated string load_balancer_ids = 14;

  string cloud_id = 11;

  // Last time when the backend group was modified.
  google.protobuf.Timestamp modified_at = 12;

  // UA or SA that created the backend group.
  string created_by = 13;

  // Next field number is 15.
}

message StreamBackendGroup {
  repeated StreamBackend backends = 1;

  // session_affinity is applicable when load_balancing_mode of the selected backend
  // is MAGLEV_HASH.
  oneof session_affinity {
    ConnectionSessionAffinity connection = 2;
  }
}

message HttpBackendGroup {
  repeated HttpBackend backends = 1;

  // session_affinity is applicable when load_balancing_mode of the selected backend
  // is MAGLEV_HASH.
  oneof session_affinity {
    ConnectionSessionAffinity connection = 2;
    HeaderSessionAffinity header = 3;
    CookieSessionAffinity cookie = 4;
  }
}

message GrpcBackendGroup {
  repeated GrpcBackend backends = 1;

  // session_affinity is applicable when load_balancing_mode of the selected backend
  // is MAGLEV_HASH.
  oneof session_affinity {
    ConnectionSessionAffinity connection = 2;
    HeaderSessionAffinity header = 3;
    CookieSessionAffinity cookie = 4;
  }
}

message HeaderSessionAffinity {
  string header_name = 1 [(length) = "1-256"];
}

message CookieSessionAffinity {
  string name = 1 [(length) = "1-256"];
  // If not set, session cookie will be used (not persisted between browser restarts).
  google.protobuf.Duration ttl = 2;
}

message ConnectionSessionAffinity {
  bool source_ip = 1;
  // NYI: 5-tuple for future UDP.
}

// TODO(iceman): support all features of BackendThresholds.
// As of now only max_connections and max_retries are supported.
message BackendThresholds {
  // Maximum connections to upstream cluster.
  // Default is 1024.
  int64 max_connections = 1;

  // Not implemented yet.
  int64 max_connections_per_instance = 2;

  // Not implemented yet.
  int64 max_rate = 3;

  // Not implemented yet.
  int64 max_rate_per_instance = 4;

  // Maximum number of parallel retries.
  // Default is 3.
  int64 max_retries = 5;
}

enum LoadBalancingMode {
  option (cloud.api.tools.enumeration).lint_skip.unspecified_value = true;

  ROUND_ROBIN = 0;
  RANDOM = 1;
  // Using power of two choices.
  LEAST_REQUEST = 2;
  MAGLEV_HASH = 3;
}

message LoadBalancingConfig {
  LoadBalancingMode mode = 1;

  // If percentage of healthy hosts in the backend is lower than panic_threshold,
  // traffic will be routed to all backends no matter what the health status is.
  // This helps to avoid healthy backends overloading  when everything is bad.
  // zero means no panic threshold.
  int64 panic_threshold = 2 [(value) = "0-100"];

  // Percent of traffic to be sent to the same availability zone.
  // The rest will be equally divided between other zones.
  // Targets should have the "locality" field.
  int64 locality_aware_routing_percent = 3 [(value) = "0-100"];

  // If set, will route requests only to the same availability zone.
  // Balancer won't know about endpoints in other zones.
  bool strict_locality = 4;
}

message HttpBackend {
  // Name.
  string name = 1 [(pattern) = "[a-z][-a-z0-9]{1,61}[a-z0-9]"];

  // Traffic will be split between backends of the same BackendGroup according to
  // their weights. Default value is 1. Negative value disables the backend.
  // Deprecated: use `backend_weight` instead.
  int64 weight = 2;

  // If set to zero, backend will be disabled.
  // If not set in all backends, they all will have equal weights.
  // Must either set or unset in all backends of the group.
  google.protobuf.Int64Value backend_weight = 16;

  LoadBalancingConfig load_balancing_config = 3;

  // Optional alternative port for all targets.
  int64 port = 4 [(value) = "0-65535"];

  oneof backend_type {
    option (exactly_one) = true;
    TargetGroupBackend target_group = 5;
    TargetBackend target = 6;
    StorageBucketBackend storage_bucket = 7;
    TargetGroupsBackend target_groups = 17;
    DynamicForwardProxyBackend dynamic_forward_proxy = 18;
  }

  // No health checks means no active health checking will be performed.
  repeated HealthCheck healthchecks = 8;

  // TLS settings for the upstream.
  BackendTls tls = 9;

  // Enables HTTP2 for upstream requests.
  // If not set, HTTP 1.1 will be used by default.
  bool use_http2 = 10;

  // Rate limits, etc.
  BackendThresholds thresholds = 11;

  PassiveHealthCheck passive_healthcheck = 12;

  // Allows proxying Websocket and other upgrades over H2 connect.
  bool allow_connect = 13;

  // Applied if use_http2 flag is set.
  Http2Options http2_options = 14;

  TcpOptions tcp_options = 15;
}

message GrpcBackend {
  // Name.
  string name = 1 [(pattern) = "[a-z][-a-z0-9]{1,61}[a-z0-9]"];

  // Traffic will be split between backends of the same BackendGroup according to
  // their weights. Default value is 1. Negative value disables the backend.
  int64 weight = 2;

  // If set to zero, backend will be disabled.
  // If not set in all backends, they all will have equal weights.
  // Must either set or unset in all backeds of the group.
  google.protobuf.Int64Value backend_weight = 13;

  LoadBalancingConfig load_balancing_config = 3;

  // Optional alternative port for all targets.
  int64 port = 4 [(value) = "0-65535"];

  oneof backend_type {
    option (exactly_one) = true;
    TargetGroupBackend target_group = 5;
    TargetBackend target = 6;
    TargetGroupsBackend target_groups = 14;
    DynamicForwardProxyBackend dynamic_forward_proxy = 15;
  }

  // No health checks means no active health checking will be performed.
  repeated HealthCheck healthchecks = 7;

  BackendTls tls = 8;

  // Rate limits, etc.
  BackendThresholds thresholds = 9;

  PassiveHealthCheck passive_healthcheck = 10;

  Http2Options http2_options = 11;
  TcpOptions tcp_options = 12;
}

message StreamBackend {
  string name = 1 [(pattern) = "[a-z][-a-z0-9]{1,61}[a-z0-9]"];

  // Traffic will be split between backends of the same BackendGroup according to
  // their weights. Default value is 1. Negative value disables the backend.
  int64 weight = 2;

  // If not set, backend will be disabled.
  google.protobuf.Int64Value backend_weight = 12;

  LoadBalancingConfig load_balancing_config = 3;

  // Optional alternative port for all targets.
  int64 port = 4 [(value) = "0-65535"];

  oneof backend_type {
    option (exactly_one) = true;
    TargetGroupBackend target_group = 5;
    TargetBackend target = 6;
    TargetGroupsBackend target_groups = 13;
    DynamicForwardProxyBackend dynamic_forward_proxy = 14;
  }

  repeated HealthCheck healthchecks = 7;

  BackendTls tls = 8;

  // Rate limits, etc.
  BackendThresholds thresholds = 9;

  PassiveHealthCheck passive_healthcheck = 10;

  TcpOptions tcp_options = 11;

  // If set, proxy protocol will be enabled for this backend.
  bool enable_proxy_protocol = 15;
}

message StorageBucketBackend {
  string bucket = 1 [(required) = true];
}

message TargetGroupBackend {
  string target_group_id = 1 [(required) = true];
}

message TargetGroupsBackend {
  repeated string target_group_ids = 1 [(size)=">0"];
}

// The difference between TargetBackend and TargetGroupBackend with
// single-endpoint NEG is the way ...
message TargetBackend {
  Target endpoint = 1 [(required) = true];
}

// Route, resolving hostname
message DynamicForwardProxyBackend {
  enum DnsLookupFamily {
      option (cloud.api.tools.enumeration).lint_skip.unspecified_value = true;
      AUTO = 0;
      IPV4 = 1;
      IPV6 = 2;
  }
  DnsLookupFamily dns_lookup_family = 1;
}

message PlaintextTransportSettings {
  // temporary hack until tfgen processes empty messages correctly
  // DO NOT USE!
  int64 placeholder=999 [deprecated=true];
}

message SecureTransportSettings {
  // SNI string for TLS connections.
  string sni = 1;

  // Common TLS options used for backend TLS connections.
  TlsOptions tls_options = 2;

  // Validation context for backend TLS connections.
  ValidationContext validation_context = 3;
}

message BackendTls {
  // SNI string for TLS connections.
  string sni = 1;

  // Common TLS options used for backend TLS connections.
  TlsOptions tls_options = 2;

  // Validation context for backend TLS connections.
  ValidationContext validation_context = 3;
}

message PassiveHealthCheck {
  // Percent of endpoints that can be disabled due to passive health checking.
  // Ignored when less than 1/N where N is the number of endpoints.
  // Default: 66.
  int64 max_ejection_percent = 1  [(value) = "0-100"];

  // Number of consecutive gateway failures (502/503/504) before endpoint ejection.
  // Default: 2.
  int64 consecutive_gateway_failure = 2;

  // Chance (percent) that endpoint will be actually ejected on consecutive gateway failures.
  // Default: 100.
  int64 enforcing_consecutive_gateway_failure = 3;

  // When endpoint is healthy, the number of ejections counter decrements after this interval.
  // Default: 10s.
  google.protobuf.Duration interval = 4;

  // Base ejection duration. The real duration grows with the number of ejections:
  // min(base_ejection_time * number_or_ejections, max_ejection_time)
  // Default: 30s.
  google.protobuf.Duration base_ejection_time = 5;

  // Maximum ejection duration.
  // Default: 5m.
  google.protobuf.Duration max_ejection_time = 6;
}

// Active health check.
message HealthCheck {
  // Time to wait for a health check response.
  google.protobuf.Duration timeout = 1 [(required) = true];

  // Interval between health checks.
  google.protobuf.Duration interval = 2 [(required) = true];

  // TODO: Not implemented yet.
  double interval_jitter_percent = 3;

  // Number of consecutive successful health checks required to promote endpoint
  // into the healthy state. 0 means 1.
  // Note that during startup, only a single successful health check is required to mark a host healthy.
  int64 healthy_threshold = 4;

  // Number of consecutive failed health checks required to demote endpoint
  // into the unhealthy state. 0 means 1.
  // Note that for HTTP health checks, a single 503 immediately makes endpoint unhealthy.
  int64 unhealthy_threshold = 5;

  // Optional alternative port for health checking.
  int64 healthcheck_port = 6 [(value) = "0-65535"];

  // TCP (+TLS) health check ("Stream protocol HC").
  message StreamHealthCheck {
    // Optional message to send.
    // If empty, it's a connect-only health check.
    Payload send = 1;

    // Optional text to search in reply.
    // TODO: make it repeated as in Envoy.
    Payload receive = 2;
  }

  message HttpHealthCheck {
    // Optional "Host" HTTP header value.
    string host = 1;

    // HTTP path.
    string path = 2 [(required) = true];

    // If set, health checks will use HTTP/2.
    bool use_http2 = 3;

    // Payload expected_response = 4;
  }

  message GrpcHealthCheck {
    // Optional service name for grpc.health.v1.HealthCheckRequest message.
    string service_name = 1;
  }

  oneof healthcheck {
    option (exactly_one) = true;
    StreamHealthCheck stream = 7;
    HttpHealthCheck http = 8;
    GrpcHealthCheck grpc = 9;
  }

  // Optional alternative HealthCheck's transport socket to be used by all the Health Checks in the cluster.
  // If this field is unset, each HealthCheck uses the socket of the Endpoint that it checks.
  // This is the default behaviour which can be overridden by setting this field.
  oneof transport_settings {
    PlaintextTransportSettings plaintext = 10;
    SecureTransportSettings tls = 11;
  }
}
