syntax = "proto3";

package yandex.cloud.priv.datatransfer.v1;

option go_package = "a.yandex-team.ru/cloud/bitbucket/private-api/yandex/cloud/priv/datatransfer/v1;tm_server";

import "google/api/annotations.proto";
import "google/protobuf/field_mask.proto";
import "yandex/cloud/priv/datatransfer/v1/endpoint.proto";
import "yandex/cloud/priv/datatransfer/v1/transfer.proto";
import "yandex/cloud/priv/datatransfer/v1/endpoint/clickhouse.proto";
import "yandex/cloud/priv/datatransfer/v1/endpoint/common.proto";
import "yandex/cloud/priv/datatransfer/v1/endpoint/empty.proto";
import "yandex/cloud/priv/datatransfer/v1/endpoint/greenplum.proto";
import "yandex/cloud/priv/datatransfer/v1/endpoint/kafka.proto";
import "yandex/cloud/priv/datatransfer/v1/endpoint/logbroker.proto";
import "yandex/cloud/priv/datatransfer/v1/endpoint/logfeller.proto";
import "yandex/cloud/priv/datatransfer/v1/endpoint/mongo.proto";
import "yandex/cloud/priv/datatransfer/v1/endpoint/mysql.proto";
import "yandex/cloud/priv/datatransfer/v1/endpoint/object_storage.proto";
import "yandex/cloud/priv/datatransfer/v1/endpoint/postgres.proto";
import "yandex/cloud/priv/datatransfer/v1/endpoint/ydb.proto";
import "yandex/cloud/priv/datatransfer/v1/endpoint/yds.proto";
import "yandex/cloud/priv/datatransfer/v1/endpoint/yt.proto";
import "yandex/cloud/priv/datatransfer/v1/endpoint/oracle.proto";
import "yandex/cloud/priv/datatransfer/v1/endpoint/eventhub.proto";
import "yandex/cloud/priv/datatransfer/v1/endpoint/airbyte/s3_source.proto";
import "yandex/cloud/priv/datatransfer/v1/legacyendpoint/mongo.proto";
import "yandex/cloud/priv/datatransfer/v1/legacyendpoint/mysql.proto";
import "yandex/cloud/priv/datatransfer/v1/legacyendpoint/logbroker.proto";
import "yandex/cloud/priv/datatransfer/v1/legacyendpoint/postgres.proto";
import "yandex/cloud/api/operation.proto";
import "yandex/cloud/priv/operation/operation.proto";

service EndpointService {
    rpc Get(GetEndpointRequest) returns (Endpoint) {
        option (google.api.http) = { get: "/v1/endpoint/{endpoint_id}" };
    }
    rpc List(ListEndpointsRequest) returns (ListEndpointsResponse) {
        option (google.api.http) = { get: "/v1/endpoints/list/{folder_id}" };
    }
    rpc Create(CreateEndpointRequest) returns (operation.Operation) {
        option (google.api.http) = { post: "/v1/endpoint" body: "*" };
        option (api.operation) = {
            metadata: "CreateEndpointMetadata"
            response: "Endpoint"
        };
    }
    rpc Update(UpdateEndpointRequest) returns (operation.Operation) {
        option (google.api.http) = { patch: "/v1/endpoint/{endpoint_id}" body: "*" };
        option (api.operation) = {
            metadata: "UpdateEndpointMetadata"
            response: "Endpoint"
        };
    }
    rpc Delete(DeleteEndpointRequest) returns (operation.Operation) {
        option (google.api.http) = { delete: "/v1/endpoint/{endpoint_id}" };
        option (api.operation) = {
            metadata: "DeleteEndpointMetadata"
            response: "google.protobuf.Empty"
        };
    }
    rpc ListTransfers(ListEndpointTransfersRequest) returns (ListEndpointTransfersResponse) {
        option (google.api.http) = { get: "/v1/endpoint/{endpoint_id}/transfers" };
    }
}
message GetEndpointRequest {
    string endpoint_id = 1;
}
message ListEndpointsRequest {
    // Identifier of the folder containing the endpoints to be listed.
    string folder_id = 1;
    // The maximum number of endpoints to be sent in the response message. If the
    // folder contains more endpoints than page_size, next_page_token will be included
    // in the response message. Include it into the subsequent ListEndpointRequest to
    // fetch the next page. Defaults to 100 if not specified. The maximum allowed value
    // for this field is 500.
    int64 page_size = 2;
    // Opaque value identifying the endpoints page to be fetched. Should be empty in
    // the first ListEndpointsRequest. Subsequent request should have this field filled
    // with the next_page_token from the previous ListEndpointsResponse.
    string page_token = 3;
}
message ListEndpointsResponse {
    // The list of endpoints. If there are more endpoints in the folder, then
    // next_page_token is a non-empty string to be included into the subsequent
    // ListEndpointsRequest to fetch the next endpoints page.
    repeated Endpoint endpoints = 1;
    // Opaque value identifying the next endpoints page. This field is empty if there
    // are no more endpoints in the folder. Otherwise it is non-empty and should be
    // included in the subsequent ListEndpointsRequest to fetch the next endpoints
    // page.
    string next_page_token = 2;
}
message CreateEndpointRequest {
    string folder_id = 1;
    string name = 2;
    string description = 3;
    map<string,string> labels = 4;
    oneof endpoint {
        endpoint.LogbrokerSource logbroker_v2_source = 55;
        endpoint.MysqlSource mysql_source = 44;
        endpoint.PostgresSource postgres_source = 45;
        endpoint.YdbSource ydb_source = 22;
        endpoint.EmptyTarget empty_source = 24;
        endpoint.LogfellerSource logfeller_source = 27;
        endpoint.YDSSource yds_source = 29;
        endpoint.KafkaSource kafka_source = 48;
        endpoint.MongoSource mongo_source = 50;
        endpoint.ClickhouseSource clickhouse_source = 53;
        endpoint.GreenplumSource greenplum_source = 59;
        endpoint.OracleSource oracle_source = 54;
        endpoint.EventhubSource eventhub_source = 57;
        endpoint.airbyte.S3Source s3_source = 58;
        endpoint.YtSource yt_source = 62;
        endpoint.MysqlTarget mysql_target = 46;
        endpoint.PostgresTarget postgres_target = 47;
        endpoint.GreenplumTarget greenplum_target = 61;
        endpoint.YtTarget yt_target = 30;
        endpoint.ClickhouseTarget clickhouse_target = 31;
        endpoint.YdbTarget ydb_target = 32;
        endpoint.EmptyTarget empty_target = 33;
        endpoint.LogfellerTarget logfeller_target = 39;
        endpoint.ObjectStorageTarget object_storage_target = 43;
        endpoint.KafkaTarget kafka_target = 49;
        endpoint.MongoTarget mongo_target = 51;
        endpoint.LogbrokerTarget logbroker_v2_target = 56;
        legacyendpoint.LogbrokerSource logbroker_source = 23;
        legacyendpoint.ManagedPostgresSource managed_postgres_source = 20;
        legacyendpoint.OnPremisePostgresSource on_premise_postgres_source = 25;
        legacyendpoint.ManagedMysqlSource managed_mysql_source = 21;
        legacyendpoint.OnPremiseMysqlSource on_premise_mysql_source = 26;
        legacyendpoint.MongoSource on_premise_mongo_source = 28;
        legacyendpoint.ManagedMongoSource managed_mongo_source = 41;
        legacyendpoint.MongoTarget on_premise_mongo_target = 40;
        legacyendpoint.ManagedMongoTarget managed_mongo_target = 42;
        legacyendpoint.ManagedMysqlTarget managed_mysql_target = 34;
        legacyendpoint.OnPremiseMysqlTarget on_premise_mysql_target = 37;
        legacyendpoint.ManagedPostgresTarget managed_postgres_target = 35;
        legacyendpoint.OnPremisePostgresTarget on_premise_postgres_target = 38;
        legacyendpoint.LogbrokerTarget logbroker_target = 36;
    }
    EndpointSettings settings = 52;
}
message CreateEndpointMetadata {
    string endpoint_id = 1;
}
message UpdateEndpointRequest {
    // Identifier of the endpoint to be updated.
    string endpoint_id = 10;
    // The new endpoint name. Must be unique within the folder.
    string name = 11;
    // The new description for the endpoint.
    string description = 12;
    map<string,string> labels = 13;
    oneof endpoint {
        endpoint.LogbrokerSource logbroker_v2_source = 55;
        endpoint.MysqlSource mysql_source = 44;
        endpoint.PostgresSource postgres_source = 45;
        endpoint.YdbSource ydb_source = 22;
        endpoint.EmptyTarget empty_source = 24;
        endpoint.LogfellerSource logfeller_source = 27;
        endpoint.YDSSource yds_source = 29;
        endpoint.KafkaSource kafka_source = 48;
        endpoint.MongoSource mongo_source = 50;
        endpoint.ClickhouseSource clickhouse_source = 53;
        endpoint.GreenplumSource greenplum_source = 59;
        endpoint.OracleSource oracle_source = 54;
        endpoint.EventhubSource eventhub_source = 57;
        endpoint.YtSource yt_source = 62;
        endpoint.MysqlTarget mysql_target = 46;
        endpoint.PostgresTarget postgres_target = 47;
        endpoint.GreenplumTarget greenplum_target = 61;
        endpoint.YtTarget yt_target = 30;
        endpoint.ClickhouseTarget clickhouse_target = 31;
        endpoint.YdbTarget ydb_target = 32;
        endpoint.EmptyTarget empty_target = 33;
        endpoint.LogfellerTarget logfeller_target = 39;
        endpoint.ObjectStorageTarget object_storage_target = 43;
        endpoint.KafkaTarget kafka_target = 49;
        endpoint.MongoTarget mongo_target = 51;
        endpoint.LogbrokerTarget logbroker_v2_target = 56;
        legacyendpoint.LogbrokerSource logbroker_source = 23;
        legacyendpoint.ManagedPostgresSource managed_postgres_source = 20;
        legacyendpoint.OnPremisePostgresSource on_premise_postgres_source = 25;
        legacyendpoint.ManagedMysqlSource managed_mysql_source = 21;
        legacyendpoint.OnPremiseMysqlSource on_premise_mysql_source = 26;
        legacyendpoint.MongoSource on_premise_mongo_source = 28;
        legacyendpoint.ManagedMongoSource managed_mongo_source = 41;
        legacyendpoint.MongoTarget on_premise_mongo_target = 40;
        legacyendpoint.ManagedMongoTarget managed_mongo_target = 42;
        legacyendpoint.ManagedMysqlTarget managed_mysql_target = 34;
        legacyendpoint.OnPremiseMysqlTarget on_premise_mysql_target = 37;
        legacyendpoint.ManagedPostgresTarget managed_postgres_target = 35;
        legacyendpoint.OnPremisePostgresTarget on_premise_postgres_target = 38;
        legacyendpoint.LogbrokerTarget logbroker_target = 36;
    }
    // The new endpoint name. Must be unique within the folder.
    EndpointSettings settings = 52;
    // Field mask specifying endpoint fields to be updated. Semantics for this field is
    // described here:
    // https://pkg.go.dev/google.golang.org/protobuf/types/known/fieldmaskpb#FieldMask
    // The only exception is that if the repeated field is specified in the mask, then
    // the new value replaces the old one instead of being appended to the old one.
    google.protobuf.FieldMask update_mask = 60;
}
message UpdateEndpointMetadata {
    string endpoint_id = 1;
}
message DeleteEndpointRequest {
    string endpoint_id = 1;
}
message DeleteEndpointMetadata {
    string endpoint_id = 1;
}
message ListEndpointTransfersRequest {
    string endpoint_id = 1;
}
message ListEndpointTransfersResponse {
    repeated Transfer transfers = 1;
}
