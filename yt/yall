#!/usr/bin/env python
# -*- coding: utf-8 -*-

from __future__ import print_function

import argparse
import os
import subprocess
import sys

KB = 1024
MB = 1024 * KB
GB = 1024 * MB
TB = 1024 * GB

YA_CACHE_YT_STORE_PROXY = "freud"
YA_CACHE_YT_DIR = "//home/yt-teamcity-build/cache"

YA_CACHE_YT_MAX_STORE_SIZE = 10 * TB
YA_CACHE_YT_STORE_TTL = 24  # hours
YA_CACHE_YT_STORE_CODEC = "zstd08_1"


def fatal_error(msg):
    print(msg, file=sys.stderr)
    exit(1)


class AlreadyUnprivileged(RuntimeError):
    pass


class ProxyUnavailable(RuntimeError):
    pass


def get_token_for_unprivileged_user():
    import yt.wrapper
    config = {
        "proxy": {
            "retries": {
                "count": 3,
                "backoff": {
                    "policy": "constant_time",
                    "constant_time": 3000,
                },
            }
        }
    }
    yt_client = yt.wrapper.YtClient(YA_CACHE_YT_STORE_PROXY, config=config)

    try:
        tokens = yt_client.get("//sys/tokens")
    except yt.wrapper.errors.YtProxyUnavailable:
        return None
    except yt.wrapper.errors.YtResponseError as e:
        if e.is_access_denied():
            raise AlreadyUnprivileged()
        raise
    except yt.wrapper.errors.YtProxyUnavailable:
        # We want caller to be able to handle this error, but we don't want it to depend on yt.wrapper
        raise ProxyUnavailable

    for token, user in tokens.items():
        if user == "robot-yt-dev-guest":
            return token

    fatal_error(
        "Cannot use dist-cache because unpriviledeged user token (robot-yt-dev-guest) cannot be found"
    )


def comma_separated_list(val):
    return val.split(",")


def get_dist_cache_args(args):
    dist_cache_args = []
    if args.yall_enable_dist_cache:
        dist_cache_args += [
            "--yt-store",
            "--yt-proxy", YA_CACHE_YT_STORE_PROXY,
            "--yt-dir", YA_CACHE_YT_DIR
        ]

        if args.yall_dist_cache_auto_token:
            # We are going to run ya make that is going to do something on our cluster.
            # In case ya make have some bug it can be quite destructive if it has superuser token.
            # Most of the users of this script have such powers.
            # So we try to get token for unpriviledeged user.
            try:
                token = get_token_for_unprivileged_user()
            except AlreadyUnprivileged:
                token = None
            except ProxyUnavailable:
                print("WARNING: cannot connect to dist cache cluster, disable dist cache", file=sys.stderr)
                return []

            if token:
                dist_cache_args += ["--yt-token", token]

        if args.yall_dist_cache_put:
            dist_cache_args += [
                "--yt-put",
                "--yt-store-codec", YA_CACHE_YT_STORE_CODEC,
                "--yt-max-store-size", str(YA_CACHE_YT_MAX_STORE_SIZE),
                "--yt-store-ttl", str(YA_CACHE_YT_STORE_TTL),
            ]
    return dist_cache_args


def get_install_bin_args(args):
    if args.yall_cmake_like_install:
        return [
            "--install",
            os.path.join(args.yall_cmake_like_install, "bin")
        ]
    else:
        return []


def get_install_python_lib_args(args, version, platform):
    if args.yall_cmake_like_install:
        parts = ["pyshared", version.replace(".", "-")]
        if "linux" not in platform:
            parts.append(platform)
        return [
            "--install",
            os.path.join(
                args.yall_cmake_like_install,
                "lib",
                "-".join(parts),
            )
        ]
    else:
        return []


def call(args, dry_run=False):
    if dry_run:
        print("Will be called:", args)
    else:
        print("Calling:", args, file=sys.stderr)
        subprocess.check_call(args)

def main():
    parser = argparse.ArgumentParser(epilog="All unrecognized options will be passed to `ya make` directly.")
    parser.add_argument("--yall-asan-build", help="enable asan during build", action="store_true")

    parser.add_argument(
        "--yall-enable-dist-cache",
        action="store_true",
        help="Enable using distributed cache from Freud.",
    )
    parser.add_argument(
        "--yall-disable-dist-cache",
        action="store_false",
        dest="yall_enable_dist_cache",
        help="Disable using distributed cache from Freud.",
    )
    parser.set_defaults(yall_enable_dist_cache=True)

    parser.add_argument(
        "--yall-dist-cache-no-auto-token",
        action="store_false",
        dest="yall_dist_cache_auto_token",
        help=(
            "When using dist-cache yall will automatically get token for unpriviledged user,\n"
            "this option disables this behaviour. Has no effect without --yall-enable-dist-cache."
        )
    )
    parser.add_argument(
        "--yall-dist-cache-put",
        action="store_true",
        help=(
            "Enable writing to distributed cache. Has no effect without --yall-enable-dist-cache.\n"
            "(This option is not recommented for use outside TeamCity since it can slow down build.)"
        )
    )
    parser.add_argument(
        "--yall-cmake-like-install",
        help=(
            "Install resulting binaries and python bindings to provided directory in cmake-like manner\n"
            "(used in TeamCity)."
        )
    )
    parser.add_argument(
        "--yall-python-version-list",
        type=comma_separated_list,
        help=(
            "Comma separated list of python version to build our bindings for.\n"
            "When not specified yall will build bindings for single version"
            " that is specified in YT_BUILD_PYTHON_VERSION environment variable.\n"
            "When this environment variable is not set version 2.7 is used.\n"
            "(It's meaningless to specify multiple versions and not to use --yall-cmake-like-install\n"
            "since bindings will override each other and only last version in the list will be availible.)\n"
        )
    )
    parser.add_argument(
        "--yall-python-platform-list",
        type=comma_separated_list,
        help=(
            "Comma separated list of platforms where python should be built.\n"
            "When not specified yall will build bindings for single version"
            " that is specified in YT_BUILD_PYTHON_PLATFORM environment variable.\n"
            "When this environment variable is not set 'linux' platform is used.\n"
            "(It's meaningless to specify multiple versions and not to use --yall-cmake-like-install\n"
            "since bindings will override each other and only last version in the list will be availible.)\n"
        )
    )
    parser.add_argument(
        "--yall-build-only",
        choices=["all", "yt", "python"],
        default="yt",
        help="build only specified preset of targets")

    parser.add_argument(
        "--yall-enable-dist-build",
        action="store_true",
        help="(Experimental) use dist build. This may produce weird errors some of which may be ignored; be careful when specifying this option")
    parser.add_argument(
        "--yall-dry-run",
        action="store_true",
        help="Instead of running commands, print their invocation lines")

    args, rest_args = parser.parse_known_args()

    buildall_args = []
    dist_build_args = []
    if args.yall_asan_build:
        buildall_args = ["--sanitize=address"]
    if args.yall_enable_dist_build:
        dist_build_args = ["--dist", "-E"]

    dist_cache_args = get_dist_cache_args(args)

    if args.yall_python_version_list is not None:
        python_version_list = args.yall_python_version_list
    else:
        python_version_list = [os.environ.get("YT_BUILD_PYTHON_VERSION", "2.7")]

    if args.yall_python_platform_list is not None:
        python_platform_list = args.yall_python_platform_list
    else:
        python_platform_list = [os.environ.get("YT_BUILD_PYTHON_PLATFORM", "linux")]

    repo_root = None
    cur_dir = os.path.dirname(os.path.realpath(__file__))
    while cur_dir != "/":
        if os.path.exists(os.path.join(cur_dir, ".arc")):
            repo_root = cur_dir
            break
        cur_dir = os.path.dirname(cur_dir)
    if repo_root is None:
        print("ERROR: failed to find repo root", file=sys.stderr)
        sys.exit(1)

    os.chdir(os.path.join(repo_root, "yt"))
    ya = os.path.join(repo_root, "ya")

    try:
        print("Building server binaries...", file=sys.stderr)
        install_args = get_install_bin_args(args)
        target = {
            "all": "buildall",
            "yt": "buildall/yt-only",
            "python": None,
        }[args.yall_build_only]
        if target is not None:
            try:
                call([ya, "make", target] + buildall_args + dist_cache_args + install_args + rest_args + dist_build_args, dry_run=args.yall_dry_run)
            except subprocess.CalledProcessError as e:
                if args.yall_enable_dist_build:
                    print("Following error was ignored:", str(e), file=sys.stderr)
                else:
                    fatal_error(str(e))


        for platform in python_platform_list:
            target_platform_args = ["--target-platform", platform]
            for version in python_version_list:
                print("Building bindings for python-{0} on platform {1}...".format(version, platform), file=sys.stderr)
                install_args = get_install_python_lib_args(args, version, platform)
                if version == "skynet":
                    python_version_args = [
                        "-DPYTHON_CONFIG=/skynet/python/bin/python-config",
                        "-DUSE_ARCADIA_PYTHON=no",
                        "-DOS_SDK=local",
                    ]
                else:
                    python_version_args = ["-DUSE_SYSTEM_PYTHON={0}".format(version)]

                try:
                    call([
                            ya, "make", "buildall/system-python",
                        ] + python_version_args + dist_cache_args + install_args + rest_args + dist_build_args + target_platform_args,
                        dry_run=args.yall_dry_run)
                except subprocess.CalledProcessError as e:
                    if args.yall_enable_dist_build:
                        print("Following error was ignored:", str(e), file=sys.stderr)
                    else:
                        fatal_error(str(e))

    except subprocess.CalledProcessError as e:
        fatal_error(str(e))


if __name__ == "__main__":
    main()
