# Стиль и форматирование кода

* Данные требования являются расширением [Arcadia C++ Style Guide](https://docs.yandex-team.ru/arcadia-cpp/cpp_style_guide). Некоторые моменты аркадийного style guide, про которые забывают чаще всего:
  * В одной секции областей видимости не могут находиться одновременно члены и методы. Области их расположения следует разделять повторным указанием области видимости. Меток областей видимости должно быть минимально возможное количество, достигаемое изменением порядка следования частей декларации класса.

  * Публичная область видимости с методами должна предшествовать ```protected``` и ```private```-областям видимости с методами. Когда знакомишься с кодом, в первую очередь обычно хочется понять его интерфейс.

  * Конструкторы следует оформлять так:
  ```
  TClass::TClass()
      : FieldA(1)
      , FieldB("value")
      , FieldC(true)
  {
      // some more
      // code here
  }
  ```

  * Запрещается смешивать field initializer-ы и инициализацию полей в конструкторе. Причина: если смешивать 2 типа инициализации, существенно проще забыть проинициализировать какой-то член класса, так как код инициализации получается «размазан» (возможно, по нескольким исходным файлам).

  * Пространства имен следует оформлять как и классы, за исключением названия.
  ```
  namespace NStl {
      namespace NPrivate {
          //все, уровень вложенности пространств имен ограничен двумя
      }

      class TVector {
      };
  }
  ```

  * Наш нормативный размер табуляции = 4. Сдвиг должен заполняться пробелами, даже если Вы и нажимаете на кнопку tab.

  * Рекомендуется оставлять пустые строки между отдельными логическими блоками кода. Это значительно улучшает его читаемость.

  * Для ссылочных типов и указателей амперсанд (&) и звёздочка (*) приклеиваются к типу данных.
  ```
  const T& value = Foo();
  void Bar(int* p);
  ```

  * В производных классах следует использовать override без virtual.
  ```
  class A {
      virtual ui32 f(ui32 k) const {
      }
  };

  class B: public A {
      ui32 f(ui32 k) const override {
      }
  };
  ```

  * Внутри ```include```-файлов запрещается использовать инструкцию ```using namespace``` за иключением подключения литералов из стандартной библиотеки.

  * Порядок включения ```include```-файлов (не важно в cpp или другой include) должен быть таким, что менее общий файл включается раньше более общего. Такой порядок позволяет лишний раз проверять на самостоятельность остальные включаемые заголовочные файлы.

* Не стесняемся использовать ```using namespace``` в ```.cpp```-файлах чтобы сократить имена типов. Если он используется, то должен располагаться в начале файле. При обращении к содержимому такого ```namespace``` внутри ```.cpp``` файла префикс с именем ```namespace``` должен отсутствовать.

* Члены-данные класса следует располагать в конце описания класса.

* Методы класса должны отделяться друг от друга пустой строкой. Последний метод в секции отделяется от следующей секции пустой строкой.

* Все блоки должны выделяться фигурными скобками, то есть так нельзя:
  ```
  if (something)
      A();
  ```

* Строка кода не должна быть длинее 120 символов.

* Длинные строки переносим просто с табуляцией. Не выравниваем аргументы функции друг под другом, чтобы избежать переформатирования при переименовании:
  ```
  THolder<IHttpAuthProvider> MakeHttpAuthProvider(const TAuthConfig& config,
      TAgentContext& context,
      TScopeLogger& logger);
  ```

* Все, что может быть помечено ```private```, должно быть помечено ```private```.

* Все, что может быть помечено ```const```, должно быть помечено ```const```.

* Флюентная часть ```CONFIG_FIELD``` (третрий аргумент), если она присутствует, должна всегда переноситься на следующую строку с табуляцией:
  ```
  CONFIG_FIELD(TAuthConfig, Auth,
      .Optional()
      .Inplace());
  ```

* Реализация методов для нешаблонных классов, а так же для шаблонов, для которых используется explicit template instantiation, должна располагаться в .cpp-файлах.

* Имена директорий и файлов должны быть согласованы: ```output```-плагин с именем ```yc_logs``` должен быть в файле ```yc_logs_output.cpp``` в директории ```yc_logs_output```. Классы плагинов обычно называются ```TPlugin``` и располагаются в анонимном неймспейсе.

* В хедерах не должно быть не ```constexpr```-объявлений переменных; то есть могут быть только функции, классы, шаблоны и ```constexpr```-переменные.

* В параметрах ```Y_VERIFY``` можно использовать только ```inplace```-выражения, чтобы они вычислялись только если условие ложно. Можно для этого использовать ```inplace lambda```:
  ```
      Y_VERIFY("value [%lu] exceeds the limit [%lu]", theValue, [](){ /* logic to calculate the limit */ }());
  ```

  Это может быть полезно, если хочется дать расширенный контекст, например текущий запрос в виде сериализованного протобуфа:
  ```
      Y_VERIFY("message, request [%s]", request.ShortDebugString().c_str());
  ```

* Литералы с типом map удобно и красиво форматировать так:
  ```
      const auto map = THashMap<TString, TString> {
          {"key1", "value1"},
          {"key2", "value2"}
      };
  ```

* Fluent-ные цепочки вызовов форматируем так:
  ```
  auto result = NJson::TJsonWriterConfig()
      .SetFormatOutput(format == EOutputFormat::PrettyJson)
      .SetUnbuffered(true)
      .SetValidateUtf8(false);
  ```

# Семантика

* В текстах ошибок, в ```exception```-ах и в логах, всегда сообщаем значения релевантных динамических параметров системы, из-за неверного соотношения которых ошибка случилась. ```message dropped because it's too large``` — так плохо. ```message dropped because it's size [%lu] exceeds the size limit [%lu]``` — так лучше. Сами значения заключаем в ```[]``` чтобы не было путаницы, когда значение параметра — пустая строка. Еще лучше — дать рекомендацию пользователю, как он может исправить эту ошибку, ссылка на соответствующий раздел документации.

* В коде стараемся избегать copy paste с помощью выделения абстракций. Используем наиболее простую конструкцию языка, которая позволяют решить проблему (локальная переменная -> функция -> ```lambda``` -> класс -> иерархия классов -> шаблон -> макрос).

* Стараемся не оставлять ```todo_``` в коде:
  * Несложные улучшения делаем прямо сейчас, в моменте, пока контекст не потерян.

  * Для более сложных заводим отдельные тикеты. В релевантном месте в коде можно оставить ```todo_``` со ссылкой на этот тикет.

* Если ```private```-часть класса зависит от множества хедеров, которые не нужны для ```public```-части, следует рассмотреть возможность выделения для класса явного интерфейса, [пример](https://a.yandex-team.ru/arc/trunk/arcadia/logbroker/unified_agent/plugins/metrics_module/lib/metrics_aggregator.h).

* Для проверки инвариантов в коде используем ```Y_VERIFY```, не ```Y_ASSERT``` или ```Y_ENSURE```:
  * Сломанный инвариант означает, что поведение программы непредсказуемо. Завершив ее как можно раньше мы минимизируем потенциальный вред.

  * Аварийно завершающаяся программа — явный и недвусмыслленный сигнал о проблемах в коде. Релиз нужно откатывать, или делать quick fix ASAP. При других вариантах проблема может очень долго оставаться незамеченной.

  * Это повышает ответственность при формулировании условий инвариантов.

* При решении тикетов стараемся взглянуть на проблему шире, увидеть контекст. Возможно мы имеем дело с частным случаем какой-то более общей проблемы, и решив ее в общем случае мы избежим повторения аналогичных проблем в будущем.

* Избегаем [«преждевременной пессимизации»](https://www.oreilly.com/library/view/c-coding-standards/0321113586/ch10.html). Если код небольшими усилиями или выбором более подходящих структур данных можно сделать более эффективным — делаем это.

* Следим за стабильностью тестов, чиним флапы, стараемся постоянно поддерживать их в зеленом состоянии. Если прогон на ```CI``` красный, это повод отложить текущую задачу и починить его.

# Тестирование

Тесты на плагины пишем на ```C++```, через запуск агента, в директории ```tests/integration``` есть вся инфраструктура для этого.

Модульные тесты пишем на компоненты со стабильным интерфейсом и нетривиальной логикой, [пример](https://a.yandex-team.ru/arc/trunk/arcadia/logbroker/unified_agent/tests/ut/config_node/config_node_ut.cpp), либо если протестировать компонент через запуск агента становится слишком сложно, но это случается редко.

Причина: модульные тесты, особенно с использованием ```mock```-ов, добавляют очень много связности в код. Если интерфейс компонента не устоялся, любой рефакторинг будет требовать исправления тестов, и это будет препятствовать развитию кода через рефакторинг. Кроме того, связность проявляется и через зависимости. Чтобы, например, протестировать какой-то нюанс внутри ```storage``` потребуется воссоздать все окружение, в котором работает соответствующий компонент, и поддерживать это окружение при последующих рефакторингах. ```integration```-тесты позволяют не думать об этом и использовать стандартное окружение. Кроме того, они позволяют убедиться, что компонент хорошо стыкуется со всеми другими механизмами, и что конечный видимый пользователю результат адекватен.

Сами интеграционные тесты обычно бывают двух типов: тесты пользовательского сценария, и тесты на конкретные фичи. Тест пользовательского сценария проверяет, что компонент работает на некотором типичном конфиге. Чем ближе этот конфиг к реальному конфигу — тем лучше. Тест на фичу проверят, что конкретный нюанс компонента работает так как положено. Такие тесты не должны содержать лишней логики, ни в коде теста ни в конфиге. Чем проще они для понимания — тем лучше.
